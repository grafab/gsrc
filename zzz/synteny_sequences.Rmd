---
title: "Synteny from Sequences"
author: "Fabian Grandke"
date: "`r Sys.Date()`"
output: rmarkdown::pdf_document
vignette: >
  %\VignetteIndexEntry{Synteny Blocks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

#Introduction
This is a manual to show how synteny can be calculated from scratch.
In the other synteny vignette we demonstrate how synteny blocks are created for a given set of already mapped unigenes.
This kind of data is not available for all species and alternative resources have to be used.
Here we require only two sequence files in FASTA format and make use of the powerful _DECIPHER_ package.
The sequences can be from closely related species or subgenomes of allopolyploids.
We show the step by step procedure with publicly available data from allotetraploid canola and cotton.

#Canola
##Data
First we download the data from:
[http://www.genoscope.cns.fr/brassicanapus/data/](http://www.genoscope.cns.fr/brassicanapus/data/Brassica_napus_v4.1.chromosomes.fa.gz) and extract it into a local directory.
Next we split the file after the A genome (line 3977960) and the C genome (line 10756668) because both subgenomes are merged into one file together with some random contigs.
Subgenomes A and C consist of 10 and 9 chromosomes, respectively.
Each chromosome has a header line in the FASTA file which starts with > followed by the chromosome ID.
In UNIX environments the _head_ and _tail_ commands can be used to extract the first and last lines of a file.

```{r, results="hide", eval=FALSE}
library(DECIPHER)
library(dbscan)
library(gsrc)
```

##DECIPHER
To calculate synteny positions, we apply the code provided by the DECIPHER authors  [http://decipher.cee.wisc.edu](http://decipher.cee.wisc.edu/Screenshots/Example6.html).
The computation can take quite some time and we want to save it.
If you have access to a multi-core system, assign multiple cores using the _processors_ parameter and increase the memory with the _storage_ parameter.
_PATHTOGENOME1_ and _PATHTOGENOME2_ are the files we just created by splitting the downloaded FASTA file.
_PATHTODB_ and _PATHTOSYNTENYFILE_ are files that DECIPHER will create.
```{r, eval = FALSE}
fas <- c(Genome1="PATHTOGENOME1",   
         Genome2="PATHTOGENOME2")
db <- "PATHTODB"
for (i in seq_along(fas)) {   
  Seqs2DB(fas[i], "FASTA", db, names(fas[i]))
}
synteny <- FindSynteny(db, processors = NULL, storage = 5)
save(synteny, file = "PATHTOSYNTENYFILE")
```

##Synteny blocks
Next, we calculate synteny blocks from the mapped sequences.
We extract the required data from the synteny object, filter, transform and calculate global positions.
The _FindSynteny_ returns a list of results, but we only need the second object.

```{r, results = "hide"}
load("/home/fabian/jlu/indel/synteny/brassica_synteny.Rdata")
```
```{r}
syn_uni <- as.data.frame(synteny[[2]])
syn_uni <- syn_uni[syn_uni$score>1500,]
syn_uni <- syn_uni[, c(1,5,7,2,6,8)]
syn_uni <- cbind(syn_uni, rowMeans(syn_uni[, 2:3]), rowMeans(syn_uni[, 5:6]))
syn_uni <- syn_uni[, c(1,7,4,8)]
colnames(syn_uni) <- c("index1", "start1", "index2", "start2")
syn_uni <- syn_uni[order(syn_uni$index1, syn_uni$start1),]
syn_uni$Alev <- as.factor(syn_uni$index1)
syn_uni$Clev <- as.factor(syn_uni$index2)
syn_uni$AGlo <- syn_uni$start1
syn_uni$CGlo <- syn_uni$start2
amaxs <- sapply(levels(syn_uni$Alev), function(x) max(syn_uni$start1[syn_uni$index1==x]))
for(i in 2:length(levels(syn_uni$Alev))){
  syn_uni$AGlo[syn_uni$index1 == levels(syn_uni$Alev)[i]] <- syn_uni$AGlo[syn_uni$index1 == levels(syn_uni$Alev)[i]] + sum(amaxs[1:(i-1)])
}

cmaxs <- sapply(levels(syn_uni$Clev), function(x) max(syn_uni$start2[syn_uni$index2==x]))
for(i in 2:length(levels(syn_uni$Clev))){
  syn_uni$CGlo[syn_uni$index2 == levels(syn_uni$Clev)[i]] <- syn_uni$CGlo[syn_uni$index2 == levels(syn_uni$Clev)[i]] + sum(cmaxs[1:(i-1)])
}
csamax <- cumsum(amaxs)
cscmax <- cumsum(cmaxs)

```
We visualize the data and see a general synteny structure in the data.
```{r, fig.show = "hold", fig.width = 8, fig.height = 8}
plot(syn_uni$AGlo, syn_uni$CGlo, pch = 19, cex = 0.2, col = rgb(0, 0, 0, alpha = 0.05))
abline(v = c(0, csamax), h=c(0, cscmax))
```
We extract the required columns and name them.
```{r}
syn_uni2 <- syn_uni[, c(1, 2, 3, 4)]
names(syn_uni2) <- c("chr1", "pos1", "chr2", "pos2")
```

Once, we have a suitable data.frame with four columns, we call _find_blocks_.
```{r}
blocks <- gsrc::find_blocks(syn_uni2, eps = 1500000, minPts = 20, minLength = 1000000, maxLength = 10000000)
```

Finally, we visualize the result.
The chromsome numbers do not necessarily represent the official chromosome names, but the order of the sequences in the FASTA file.
```{r, fig.show = "hold", fig.width = 9, fig.height = 5}
plot.new()
cols <- rainbow(
  n = 10, start = 0, end = 1, alpha = 0.2
)
max1 <- max(blocks$blocks$end1)
max2 <- max(blocks$blocks$end2)
axis(
  3, at = (csamax - min(amaxs) / 2) / max(csamax),
  labels = sort(unique(blocks$blocks$chr1)), tick = FALSE, cex.axis = 0.8, las = 1
)
axis(
  1, at = (cscmax - min(cmaxs) / 2) / max(cscmax),
  labels = sort(unique(blocks$blocks$chr2)), tick = FALSE, cex.axis = 0.8, las = 1
)
y <- c(1, 1, 0, 0)
for (i in 1:nrow(blocks$blocks)) {
  x <- c(
    blocks$blocks$start1[i],
    blocks$blocks$end1[i],
    blocks$blocks$end2[i],
    blocks$blocks$start2[i]
  )
  x <- c(x[1:2] / max1, x[3:4] / max2)
  polygon(x, y, col = cols[unique(blocks$blocks$chr1) %in% blocks$blocks$chr1[i]])
}
```


#Cotton
##Data
First we download the data from:
[https://www.cottongen.org/data/download/genome](ftp://ftp.bioinfo.wsu.edu/species/Gossypium_hirsutum/NAU-NBI_G.hirsutum_AD1genome/assembly/AD1-NBI_v1.1_chromosomes_only.fas.gz) and extract it into a local directory.
Next we split the file after line 26 because both subgenomes are merged into one file.
Each subgenome consists of 13 chromosomes and each chromosome has a header line in the FASTA file.
In UNIX environments the _split_ can be used.

```{r, results="hide", eval=FALSE}
library(DECIPHER)
library(dbscan)
library(gsrc)
```

##DECIPHER
To calculate synteny positions, we apply the code provided by the DECIPHER authors  [http://decipher.cee.wisc.edu](http://decipher.cee.wisc.edu/Screenshots/Example6.html).
The computation can take quite some time and we want to save it.
If you have access to a multi-core system, assign multiple cores using the _processors_ parameter and increase the memory with the _storage_ parameter.
_PATHTOGENOME1_ and _PATHTOGENOME2_ are the files we just created by splitting the downloaded FASTA file.
_PATHTODB_ and _PATHTOSYNTENYFILE_ are files that DECIPHER will create.
```{r, eval = FALSE}
fas <- c(Genome1="PATHTOGENOME1",   
         Genome2="PATHTOGENOME2")
db <- "PATHTODB"
for (i in seq_along(fas)) {   
  Seqs2DB(fas[i], "FASTA", db, names(fas[i]))
}
synteny <- FindSynteny(db, processors = NULL, storage = 5)
save(synteny, file = "PATHTOSYNTENYFILE")
```

##Synteny blocks
Next, we calculate synteny blocks from the mapped sequences.
We extract the required data from the synteny object, transform it and calculate global positions.
The _FindSynteny_ returns a list of results, but we only need the second object.

```{r, results = "hide"}
load("/home/fabian/jlu/indel/synteny/cotton_synteny.Rdata")
```
```{r}
syn_uni <- as.data.frame(synteny[[2]])
syn_uni <- syn_uni[syn_uni$score>1500,]
syn_uni <- syn_uni[, c(1,5,7,2,6,8)]
syn_uni <- cbind(syn_uni, rowMeans(syn_uni[, 2:3]), rowMeans(syn_uni[, 5:6]))
syn_uni <- syn_uni[, c(1,7,4,8)]
colnames(syn_uni) <- c("index1", "start1", "index2", "start2")
syn_uni <- syn_uni[order(syn_uni$index1, syn_uni$start1),]
syn_uni$Alev <- as.factor(syn_uni$index1)
syn_uni$Clev <- as.factor(syn_uni$index2)
syn_uni$AGlo <- syn_uni$start1
syn_uni$CGlo <- syn_uni$start2
amaxs <- sapply(levels(syn_uni$Alev), function(x) max(syn_uni$start1[syn_uni$index1==x]))
for(i in 2:length(levels(syn_uni$Alev))){
  syn_uni$AGlo[syn_uni$index1 == levels(syn_uni$Alev)[i]] <- syn_uni$AGlo[syn_uni$index1 == levels(syn_uni$Alev)[i]] + sum(amaxs[1:(i-1)])
}

cmaxs <- sapply(levels(syn_uni$Clev), function(x) max(syn_uni$start2[syn_uni$index2==x]))
for(i in 2:length(levels(syn_uni$Clev))){
  syn_uni$CGlo[syn_uni$index2 == levels(syn_uni$Clev)[i]] <- syn_uni$CGlo[syn_uni$index2 == levels(syn_uni$Clev)[i]] + sum(cmaxs[1:(i-1)])
}
csamax <- cumsum(amaxs)
cscmax <- cumsum(cmaxs)
```
We visualize the data and see a general synteny structure in the data.
```{r, fig.show = "hold", fig.width = 8, fig.height = 8}
plot(syn_uni$AGlo, syn_uni$CGlo, pch = 19, cex = 0.2, col = rgb(0, 0, 0, alpha = 0.05))
abline(v = c(0, csamax), h=c(0, cscmax))
```
We extract the required columns and name them.
```{r}
syn_uni2 <- syn_uni[, c(1, 2, 3, 4)]
names(syn_uni2) <- c("chr1", "pos1", "chr2", "pos2")
```

Once, we have a suitable data.frame with four columns, we call _find_blocks_.
```{r}
blocks <- gsrc::find_blocks(syn_uni2,eps = 5000000, minPts = 20, minLength = 10000000, maxLength = 50000000)
```

Finally, we visualize the result.
The chromsome numbers do not necessarily represent the official chromosome names, but the order of the sequences in the FASTA file.
```{r, fig.show = "hold", fig.width = 9, fig.height = 5}
plot.new()
cols <- rainbow(
  n = 13, start = 0, end = 1, alpha = 0.2
)
max1 <- max(blocks$blocks$end1)
max2 <- max(blocks$blocks$end2)
axis(
  3, at = (csamax - min(amaxs) / 2) / max(csamax),
  labels = unique(blocks$blocks$chr1), tick = FALSE, cex.axis = 0.8, las = 1
)
axis(
  1, at = (cscmax - min(cmaxs) / 2) / max(cscmax),
  labels = unique(blocks$blocks$chr2), tick = FALSE, cex.axis = 0.8, las = 1
)
y <- c(1, 1, 0, 0)
for (i in 1:nrow(blocks$blocks)) {
  x <- c(
    blocks$blocks$start1[i],
    blocks$blocks$end1[i],
    blocks$blocks$end2[i],
    blocks$blocks$start2[i]
  )
  x <- c(x[1:2] / max1, x[3:4] / max2)
  polygon(x, y, col = cols[unique(blocks$blocks$chr1) %in% blocks$blocks$chr1[i]])
}
```

