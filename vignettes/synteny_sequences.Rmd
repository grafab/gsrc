---
title: "Synteny from Sequences"
author: "Fabian Grandke"
date: "March 1, 2016"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Synteny Blocks}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

#Introduction
This is a manual to show how synteny can be calculated from scratch.
In the other synteny vignette we demonstrate how synteny blocks are create for a given set of mapped unigenes.
This kind of data is not available for all species and other resources have to be used.
Hence, we require only two sequence files in FASTA format and make use of the powerful _DECIPHER_ package.
The sequences can be from closely related species or subgenomes of allopolyploids.
We show the step by step procedure with data from allotetraploid cotton.

#Data
First we download the data from:
[https://www.cottongen.org/data/download/genome](ftp://ftp.bioinfo.wsu.edu/species/Gossypium_hirsutum/NAU-NBI_G.hirsutum_AD1genome/assembly/AD1-NBI_v1.1_chromosomes_only.fas.gz) and extract it into a local directory.
Next we split the file after line 26 because both subgenomes are merged into one file.
Each subgenome consists of 13 chromosomes and each chromosome has a header line in the FASTA file.
In UNIX environments the _split_ can be used.

```{r, results="hide", eval=FALSE}
library(DECIPHER)
library(dbscan)
library(gsrc)
```

#DECIPHER
To calculate synteny positions, we simply apply the code explained in [http://decipher.cee.wisc.edu](http://decipher.cee.wisc.edu/Screenshots/Example6.html).
The computation can take quite some time and you we want to save it.
If you have access to a multi-core system, assign multiple cores using the _processors_ parameter and increase the memory with the _storage_ parameter.
_PATHTOGENOME1_ and _PATHTOGENOME2_ are the files we just created by splitting the downloaded FASTA file.
_PATHTODB_ and _PATHTOSYNTENYFILE_ are files that DECIPHER will create.
```{r, eval = FALSE}
fas <- c(Genome1="PATHTOGENOME1",   
         Genome2="PATHTOGENOME2")
db <- "PATHTODB"
for (i in seq_along(fas)) {   
  Seqs2DB(fas[i], "FASTA", db, names(fas[i]))
}
synteny <- FindSynteny(db, processors = NULL, storage = 5)
save(synteny, file = "PATHTOSYNTENYFILE")
```

#Synteny blocks
Next, we calculate synteny blocks from the individual positions.
We extract the required data from the synteny object, transform it and calculate global positions.

```{r, results = "hide"}
load("/home/fabian/jlu/indel/synteny/cotton_synteny.Rdata")
```
```{r}
syn_uni <- as.data.frame(synteny[[2]][, c(1,5,7,2,6,8)])
syn_uni <- cbind(syn_uni, rowMeans(syn_uni[, 2:3]), rowMeans(syn_uni[, 5:6]))
syn_uni <- syn_uni[, c(1,7,4,8)]
colnames(syn_uni) <- c("index1", "start1", "index2", "start2")
syn_uni <- syn_uni[order(syn_uni$index1, syn_uni$start1),]
syn_uni$Alev <- as.factor(syn_uni$index1)
syn_uni$Clev <- as.factor(syn_uni$index2)
syn_uni$AGlo <- syn_uni$start1
syn_uni$CGlo <- syn_uni$start2
amaxs <- sapply(levels(syn_uni$Alev), function(x) max(syn_uni$start1[syn_uni$index1==x]))
for(i in 2:length(levels(syn_uni$Alev))){
  syn_uni$AGlo[syn_uni$index1 == levels(syn_uni$Alev)[i]] <- syn_uni$AGlo[syn_uni$index1 == levels(syn_uni$Alev)[i]] + sum(amaxs[1:(i-1)])
}

cmaxs <- sapply(levels(syn_uni$Clev), function(x) max(syn_uni$start2[syn_uni$index2==x]))
for(i in 2:length(levels(syn_uni$Clev))){
  syn_uni$CGlo[syn_uni$index2 == levels(syn_uni$Clev)[i]] <- syn_uni$CGlo[syn_uni$index2 == levels(syn_uni$Clev)[i]] + sum(cmaxs[1:(i-1)])
}
csamax <- cumsum(amaxs)
cscmax <- cumsum(cmaxs)
```
We visualize the data and see a general synteny structure in the data.
```{r, fig.show = "hold", fig.width = 8, fig.height = 8}
plot(syn_uni$AGlo, syn_uni$CGlo, pch = 19,cex=0.2, col = rgb(0,0,0,alpha = 0.05))
abline(v = c(0, csamax), h=c(0, cscmax))
```
We extract the required columns and name them.
```{r}
syn_uni2 <- syn_uni[, c(1,2,3,4)]
names(syn_uni2) <- c("chr1", "pos1", "chr2", "pos2")
```

Once, we have a suitable data.frame with four columns, we call _find_blocks_.
```{r}
blocks <- gsrc::find_blocks(syn_uni2,eps = 5000000, minPts = 100, minLength = 10000000, maxLength = 100000000)
```

Finally, we visualize the result.
The chromsome numbers do not necessarily represent the official chromosome names, but the order of the sequences in the FASTA file.
```{r, fig.show = "hold", fig.width = 9, fig.height = 5}
plot.new()
cols <- rainbow(
  n = 13, start = 0, end = 1, alpha = 0.2
)
max1 <- max(blocks$blocks$end1)
max2 <- max(blocks$blocks$end2)
axis(
  3, at = (csamax - min(amaxs) / 2) / max(csamax),
  labels = unique(blocks$blocks$chr1), tick = FALSE, cex.axis = 0.8, las = 1
)
axis(
  1, at = (cscmax - min(cmaxs) / 2) / max(cscmax),
  labels = unique(blocks$blocks$chr2), tick = FALSE, cex.axis = 0.8, las = 1
)
y <- c(1, 1, 0, 0)
for (i in 1:nrow(blocks$blocks)) {
  x <- c(
    blocks$blocks$start1[i],
    blocks$blocks$end1[i],
    blocks$blocks$end2[i],
    blocks$blocks$start2[i]
  )
  x <- c(x[1:2] / max1, x[3:4] / max2)
  polygon(x, y, col = cols[unique(blocks$blocks$chr1) %in% blocks$blocks$chr1[i]])
}
```

```{r, cache=FALSE}
sessionInfo()
```